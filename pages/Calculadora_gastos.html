<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Organizador de E-mails (.eml) — Offline (com PDF Outlook)</title>

<!-- Estilos (Microsoft-like) -->
<style>
  :root{
    --bg:#07142a; --card: rgba(255,255,255,0.04);
    --accent:#2b89ff; --accent-2:#5fb0ff; --muted: rgba(255,255,255,0.75);
    --glass: rgba(255,255,255,0.03); --success:#5ee39b;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family: "Segoe UI", Roboto, Arial, sans-serif;
    background: linear-gradient(180deg,var(--bg) 0%, #0b2340 100%); color:#eaf4ff;}
  .wrap{max-width:980px;margin:28px auto;padding:22px;}
  header{display:flex;align-items:center;gap:18px}
  .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--accent),var(--accent-2));
    display:flex;align-items:center;justify-content:center;font-weight:700;font-size:20px;color:#052034;box-shadow:0 6px 24px rgba(43,137,255,0.18);}
  h1{margin:0;font-size:20px} p.lead{margin:6px 0 0;color:var(--muted);font-size:13px}

  .card{margin-top:18px;background:var(--card);border-radius:14px;padding:18px;box-shadow:0 8px 30px rgba(2,6,23,0.35);}

  .drop{border:2px dashed rgba(127,189,255,0.16);background:var(--glass);border-radius:12px;padding:28px;
    display:flex;align-items:center;gap:20px;cursor:pointer;transition:all .18s ease;min-height:150px;}
  .drop.hover{ background: rgba(93,154,255,0.06); transform:translateY(-4px); }
  .options{display:flex;gap:10px;margin-top:12px;flex-wrap:wrap}
  .chip{padding:8px 12px;background:rgba(255,255,255,0.02);border-radius:10px;font-size:13px;color:var(--muted)}
  .btn{background:var(--accent);color:#052034;padding:10px 14px;border-radius:10px;font-weight:700;border:none;cursor:pointer}
  .progressWrap{margin-top:14px}
  .bar{width:100%;height:10px;background:rgba(255,255,255,0.05);border-radius:8px;overflow:hidden}
  .bar>span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-2));width:0%}
  .list{margin-top:14px;display:grid;gap:10px}
  .item{display:flex;justify-content:space-between;gap:12px;padding:10px;border-radius:10px;background: rgba(0,0,0,0.18)}
  .badge{background:rgba(255,255,255,0.04);padding:6px 8px;border-radius:8px;font-weight:600;color:var(--muted);font-size:13px}
  footer{margin-top:18px;display:flex;justify-content:space-between;align-items:center}
  .downloadAll{background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#042034;padding:10px 14px;border-radius:10px;font-weight:800;border:none;cursor:pointer;display:none}
  pre.log{margin-top:12px;max-height:220px;overflow:auto;background:rgba(0,0,0,0.2);padding:10px;border-radius:8px;color:#dff3ff;font-size:13px}
  @media(max-width:720px){ .wrap{padding:12px} .drop{flex-direction:column;text-align:center} footer{flex-direction:column;align-items:start} }
  /* hidden container used to render email to PDF */
  #pdfRenderBox{position:fixed;left:-9999px;top:-9999px;width:800px;background:white;color:#000;padding:18px;box-shadow:0 8px 40px rgba(0,0,0,0.5);}
  .pdf-email{font-family: Arial, Helvetica, sans-serif; color:#111}
  .pdf-header{border-bottom:1px solid #ddd;padding-bottom:10px;margin-bottom:12px}
  .pdf-header h2{margin:0;font-size:16px}
  .pdf-meta{font-size:12px;color:#333;margin-top:8px}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="logo">EM</div>
      <div>
        <h1>Organizador de E-mails (.eml) — Offline (PDF estilo Outlook)</h1>
        <p class="lead">Arraste `.eml` — o app extrai anexos e gera também um PDF fiel ao estilo Outlook.</p>
      </div>
    </header>

    <div class="card">
      <div id="drop" class="drop" tabindex="0">
        <div class="info" style="flex:1">
          <h2>Arraste e solte arquivos .eml aqui</h2>
          <p class="muted">Ou clique para seleccionar. Múltiplos arquivos suportados. O PDF é gerado por email no estilo Outlook e incluído no ZIP.</p>
          <div style="margin-top:10px" class="options">
            <label class="chip"><input id="optAll" type="checkbox" checked />Extrair todos os tipos (pdf, imagens, docx...)</label>
            <label class="chip"><input id="optDate" type="checkbox" checked />Criar pasta com data</label>
            <label class="chip"><input id="optHtml" type="checkbox" checked />Incluir corpo HTML</label>
          </div>
        </div>
        <div>
          <button class="btn" id="btnBrowse">Selecionar arquivos</button>
          <input id="fileInput" type="file" accept=".eml" multiple />
        </div>
      </div>

      <div class="progressWrap">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small">Progresso global</div>
          <div class="small" id="globalPercent">0%</div>
        </div>
        <div class="bar" aria-hidden><span id="globalBar"></span></div>
      </div>

      <div class="list" id="fileList"></div>

      <footer>
        <div class="muted">Resultado local — nenhum servidor. ZIP gerado no browser.</div>
        <div>
          <a id="downloadAll" class="downloadAll">Baixar tudo (ZIP)</a>
        </div>
      </footer>

      <pre id="log" class="log" aria-live="polite"></pre>
    </div>
  </div>

  <!-- Bibliotecas necessárias -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <!-- Container invisível para montar HTML e renderizar para PDF -->
  <div id="pdfRenderBox" aria-hidden></div>

<script>
/* Versão final:
 - parse .eml
 - extrai anexos
 - gera email_outlook_style.pdf via html2canvas + jsPDF
 - inclui PDF e anexos no ZIP
*/

const { jsPDF } = window.jspdf;

const drop = document.getElementById('drop');
const fileInput = document.getElementById('fileInput');
const btnBrowse = document.getElementById('btnBrowse');
const fileList = document.getElementById('fileList');
const logEl = document.getElementById('log');
const downloadAllBtn = document.getElementById('downloadAll');
const globalBar = document.getElementById('globalBar');
const globalPercent = document.getElementById('globalPercent');
const optAll = document.getElementById('optAll');
const optDate = document.getElementById('optDate');
const optHtml = document.getElementById('optHtml');
const pdfRenderBox = document.getElementById('pdfRenderBox');

btnBrowse.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', (e)=> handleFiles(e.target.files));

['dragover','drop'].forEach(ev => { window.addEventListener(ev, e => e.preventDefault()); });
['dragenter','dragover'].forEach(ev => {
  drop.addEventListener(ev, (e)=> { e.preventDefault(); e.stopPropagation(); if(e.dataTransfer) e.dataTransfer.dropEffect='copy'; drop.classList.add('hover'); });
});
['dragleave','drop'].forEach(ev => {
  drop.addEventListener(ev, (e)=> { e.preventDefault(); e.stopPropagation(); drop.classList.remove('hover'); });
});
drop.addEventListener('drop', (e)=> { e.preventDefault(); e.stopPropagation(); handleFiles(e.dataTransfer.files); });
drop.addEventListener('click', ()=> fileInput.click());

function log(msg){ logEl.textContent += msg + "\n"; logEl.scrollTop = logEl.scrollHeight; }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
function sanitizeName(s){ if(!s) return ''; return s.replace(/\s+/g,'_').replace(/[<>:"\/\\|?*]+/g,'').replace(/\.+$/,'').slice(0,120); }

/* --- Parser e utilitários (mesma lógica robusta do anterior) --- */
function parseHeaders(headerText){
  const headers = {};
  headerText = headerText.replace(/\r?\n[ \t]+/g,' ');
  headerText.split(/\r?\n/).forEach(line=>{
    const idx = line.indexOf(':');
    if(idx>0){ const name=line.slice(0,idx).trim().toLowerCase(); const val=line.slice(idx+1).trim(); if(headers[name]) headers[name]+='\n'+val; else headers[name]=val; }
  });
  return headers;
}
function getBoundary(contentType){ if(!contentType) return null; const m = contentType.match(/boundary=(?:"([^"]+)"|([^;\s]+))/i); return m ? (m[1]||m[2]) : null; }
function stripBase64Whitespace(s){ return s.replace(/\s+/g,''); }
function base64ToUint8Array(base64){ const binary = atob(base64); const len=binary.length; const arr=new Uint8Array(len); for(let i=0;i<len;i++) arr[i]=binary.charCodeAt(i); return arr; }
function escapeHtml(s){ if(!s) return ''; return s.replace(/[&<>"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }
function splitByBoundary(body,boundary){ const delim='--'+boundary; const cleaned=body.replace(/\r\n/g,'\n'); const parts=cleaned.split(delim).map(s=>s.trim()).filter(s=>s && s!=='--'); return parts.map(p=>p.endsWith('--')?p.slice(0,-2).trim():p).filter(p=>p.length>0); }

function decodeQuotedPrintable(str){
  let res = str.replace(/=\r\n/g,''); res = res.replace(/=([0-9A-F]{2})/gi, (m,p1)=>String.fromCharCode(parseInt(p1,16))); return res;
}
function decodePartBody(partBody, cte){
  if(!cte) return partBody;
  if(cte.includes('base64')) {
    try { const b64 = stripBase64Whitespace(partBody); const bytes = base64ToUint8Array(b64); try { return new TextDecoder('utf-8',{fatal:false}).decode(bytes); } catch(e){ return atob(b64); } } catch(e){ return partBody; }
  } else if(cte.includes('quoted-printable')) return decodeQuotedPrintable(partBody);
  return partBody;
}
function extractBase64FromPart(pb, cte){
  let candidate = pb.trim();
  if(cte && cte.includes('base64')) return stripBase64Whitespace(candidate);
  const m = candidate.match(/[A-Za-z0-9+/= \r\n]{200,}/);
  return m ? stripBase64Whitespace(m[0]) : '';
}

function parseEml(text){
  text = text.replace(/\r\n/g,'\n').replace(/\r/g,'\n');
  const idx = text.indexOf('\n\n'); const headerRaw = idx>=0?text.slice(0,idx):''; const bodyRaw = idx>=0?text.slice(idx+2):'';
  const headers = parseHeaders(headerRaw);
  const subject = headers['subject']||'(sem assunto)'; const from = headers['from']||headers['sender']||''; const date = headers['date']||'';
  const to = headers['to']||'';
  const topContentType = headers['content-type']||''; const boundary = getBoundary(topContentType);
  const result = { subject, from, date, to, headers, bodyPlain:null, bodyHtml:null, attachments:[] };
  if(boundary){
    const parts = splitByBoundary(bodyRaw,boundary);
    for(const part of parts){
      const i = part.indexOf('\n\n'); if(i<0) continue;
      const ph = part.slice(0,i); const pb = part.slice(i+2); const pheaders = parseHeaders(ph);
      const ctype = pheaders['content-type']||''; const cdisp = pheaders['content-disposition']||''; const cte = (pheaders['content-transfer-encoding']||'').toLowerCase();
      let filename = null;
      const fnMatch = (cdisp && cdisp.match(/filename=(?:"([^"]+)"|([^;\s]+))/i)) || (ctype && ctype.match(/name=(?:"([^"]+)"|([^;\s]+))/i));
      if(fnMatch) filename = (fnMatch[1]||fnMatch[2]).trim();
      if(/text\/plain/i.test(ctype) && !filename) { result.bodyPlain = decodePartBody(pb, cte); }
      else if(/text\/html/i.test(ctype) && !filename) { result.bodyHtml = decodePartBody(pb, cte); }
      else {
        if(filename){
          const contentBase64 = extractBase64FromPart(pb, cte);
          result.attachments.push({ name: filename, contentBase64, contentType: (ctype.match(/^([^;\s]+)/)||[])[1] || 'application/octet-stream', headers: pheaders });
        } else {
          const nameFromTypeMatch = ctype? ctype.match(/name=(?:"([^"]+)"|([^;\s]+))/i) : null;
          const nameFromType = nameFromTypeMatch ? (nameFromTypeMatch[1]||nameFromTypeMatch[2]) : null;
          if(nameFromType){
            const contentBase64 = extractBase64FromPart(pb, cte);
            result.attachments.push({ name: nameFromType.trim(), contentBase64, contentType: (ctype.match(/^([^;\s]+)/)||[])[1] || 'application/octet-stream', headers: pheaders });
          } else {
            const possibleBase64 = pb.match(/[A-Za-z0-9+/=\s]{200,}/);
            if(possibleBase64){
              const contentBase64 = stripBase64Whitespace(possibleBase64[0]);
              result.attachments.push({ name:'anexo_desconhecido.bin', contentBase64, contentType: (ctype.match(/^([^;\s]+)/)||[])[1] || 'application/octet-stream', headers: pheaders });
            }
          }
        }
      }
    }
  } else {
    if(/<\s*html/i.test(bodyRaw) || /<div|<p/i.test(bodyRaw)) result.bodyHtml = bodyRaw; else result.bodyPlain = bodyRaw;
  }
  if(!result.bodyHtml && result.bodyPlain && optHtml.checked) result.bodyHtml = '<pre style="white-space:pre-wrap;font-family:inherit;color:#001f3f;background:#f2fbff;padding:12px;border-radius:8px;">'+escapeHtml(result.bodyPlain)+'</pre>';
  return result;
}

/* --- RENDER TO PDF (OUTLOOK STYLE) --- 
   We create a hidden container with header + bodyHtml, then use html2canvas to render and jsPDF to create PDF(s).
*/
async function renderEmailToPdf(parsed, widthPx = 800){
  // Build a container
  pdfRenderBox.innerHTML = '';
  const wrap = document.createElement('div');
  wrap.className = 'pdf-email';
  // Header (Outlook-like)
  const hdr = document.createElement('div'); hdr.className='pdf-header';
  const title = document.createElement('h2'); title.textContent = parsed.subject || '(sem assunto)';
  hdr.appendChild(title);
  const meta = document.createElement('div'); meta.className='pdf-meta';
  meta.innerHTML = `<div><strong>From:</strong> ${escapeHtml(parsed.from||'')}</div>
                    <div><strong>To:</strong> ${escapeHtml(parsed.to||'')}</div>
                    <div><strong>Date:</strong> ${escapeHtml(parsed.date||'')}</div>`;
  hdr.appendChild(meta);
  wrap.appendChild(hdr);
  // Body: use parsed.bodyHtml if available, else bodyPlain wrapped
  const body = document.createElement('div');
  body.style.padding = '6px 0 20px';
  if(parsed.bodyHtml){
    // sanitize minimally: remove <script>
    const safe = parsed.bodyHtml.replace(/<script[\s\S]*?<\/script>/gi,'');
    body.innerHTML = safe;
  } else if(parsed.bodyPlain){
    body.innerHTML = '<pre style="white-space:pre-wrap;font-family:inherit;">' + escapeHtml(parsed.bodyPlain) + '</pre>';
  } else {
    body.innerHTML = '<div>(sem corpo)</div>';
  }
  wrap.appendChild(body);
  pdfRenderBox.appendChild(wrap);

  // Set width for consistent rendering
  pdfRenderBox.style.width = widthPx + 'px';

  // wait for images/fonts to load
  await waitImagesLoaded(pdfRenderBox);

  // render with html2canvas
  const canvas = await html2canvas(pdfRenderBox, { scale:2, useCORS:true, backgroundColor: '#ffffff' });

  // create PDF pages if height exceeds a single page
  const imgData = canvas.toDataURL('image/jpeg', 0.95);
  const pdf = new jsPDF({ unit:'pt', format:'a4' });
  // convert px to pt (1pt = 1.3333px at 96dpi) - jspdf operates in pt by default
  const pxPerPt = 96 / 72;
  const pageWidthPt = pdf.internal.pageSize.getWidth();
  const pageHeightPt = pdf.internal.pageSize.getHeight();
  const imgWidthPt = pageWidthPt;
  const imgHeightPt = (canvas.height / pxPerPt) * (pageWidthPt / (canvas.width / pxPerPt));
  // if single page:
  if(imgHeightPt <= pageHeightPt){
    pdf.addImage(imgData, 'JPEG', 0, 0, imgWidthPt, imgHeightPt);
  } else {
    // split into pages by drawing portions of canvas
    // We'll draw full image but offset by page height scaled
    let remainingHeightPx = canvas.height;
    const pageHeightPx = Math.round(pageHeightPt * pxPerPt);
    let yOffset = 0;
    while(remainingHeightPx > 0){
      const tempCanvas = document.createElement('canvas');
      const w = canvas.width;
      const h = Math.min(pageHeightPx, remainingHeightPx);
      tempCanvas.width = w;
      tempCanvas.height = h;
      const ctx = tempCanvas.getContext('2d');
      ctx.drawImage(canvas, 0, yOffset, w, h, 0, 0, w, h);
      const chunkData = tempCanvas.toDataURL('image/jpeg', 0.95);
      const chunkHeightPt = (h / pxPerPt) * (pageWidthPt / (canvas.width / pxPerPt));
      if(yOffset == 0) {
        pdf.addImage(chunkData, 'JPEG', 0, 0, imgWidthPt, chunkHeightPt);
      } else {
        pdf.addPage();
        pdf.addImage(chunkData, 'JPEG', 0, 0, imgWidthPt, chunkHeightPt);
      }
      remainingHeightPx -= h;
      yOffset += h;
    }
  }
  // return blob
  const blob = pdf.output('blob');
  return blob;
}

function waitImagesLoaded(container){
  const imgs = Array.from(container.querySelectorAll('img'));
  if(imgs.length===0) return Promise.resolve();
  return Promise.all(imgs.map(img => new Promise(res => {
    if(img.complete) return res();
    img.onload = img.onerror = ()=> res();
  })));
}

/* --- MAIN: handle files, build zip, include email PDF --- */
async function handleFiles(fileListObj){
  const files = Array.from(fileListObj).filter(f=> f.name && f.name.toLowerCase().endsWith('.eml'));
  if(files.length===0){ alert('Selecione ficheiros .eml'); return; }
  // reset UI
  fileList.innerHTML = ''; logEl.textContent = ''; downloadAllBtn.style.display='none'; globalBar.style.width='0%'; globalPercent.textContent='0%';
  const zip = new JSZip();
  const total = files.length;
  const uiItems = files.map(f => createFileRow(f.name));
  uiItems.forEach(it => fileList.appendChild(it.row));
  for(let i=0;i<files.length;i++){
    const f = files[i]; const ui = uiItems[i];
    ui.setStatus('Lendo ficheiro...');
    let text;
    try{ text = await f.text(); } catch(err){ ui.setStatus('Erro ao ler ficheiro'); log('Erro a ler ' + f.name + ': ' + err); continue; }
    ui.setSub('Parseando EML...');
    await sleep(40);
    let parsed;
    try{ parsed = parseEml(text); } catch(err){ ui.setStatus('Erro ao parsear'); ui.setSub('Verifique o .eml'); log('Erro parse ' + f.name + ': ' + err); continue; }
    ui.setStatus('Gerando pasta e arquivos...');
    const dt = new Date(parsed.date || Date.now());
    const dateStr = optDate.checked ? dt.toISOString().slice(0,10).replace(/-/g,'') + '_' : '';
    const subjClean = sanitizeName(parsed.subject || 'sem_assunto');
    const folderName = dateStr + subjClean;
    const folder = zip.folder(folderName);
    // metadata + bodies
    const meta = `Remetente: ${parsed.from || ''}\nAssunto: ${parsed.subject || ''}\nData: ${parsed.date || ''}\nPara: ${parsed.to || ''}\n`;
    folder.file('info.txt', meta);
    if(parsed.bodyPlain) folder.file('corpo.txt', parsed.bodyPlain);
    if(parsed.bodyHtml && optHtml.checked) folder.file('corpo.html', '<!doctype html><meta charset="utf-8">'+parsed.bodyHtml);
    // attachments
    ui.setSub('Salvando anexos...');
    let savedAttachments = 0;
    if(parsed.attachments && parsed.attachments.length){
      const attFolder = folder.folder('anexos');
      for(let aidx=0;aidx<parsed.attachments.length;aidx++){
        const att = parsed.attachments[aidx];
        if(!att || !att.contentBase64) continue;
        const rawName = att.name || ('anexo_' + (aidx+1)); const safeName = sanitizeName(rawName);
        if(!optAll.checked){
          const allowed = ['pdf','jpeg','jpg','png','gif','doc','docx','xls','xlsx','csv','txt','ppt','pptx'];
          const hasAllowedExt = allowed.some(ext => safeName.toLowerCase().endsWith('.' + ext));
          const isPdfOrImage = /pdf|image\//.test((att.contentType||'').toLowerCase());
          if(!hasAllowedExt && !isPdfOrImage){ ui.appendLog('Ignorado (não permitido): ' + safeName); continue; }
        }
        try{
          const arr = base64ToUint8Array(att.contentBase64);
          attFolder.file(safeName, arr);
          savedAttachments++; ui.appendLog('Anexo salvo: ' + safeName);
        }catch(err){ log('Erro salvar anexo ' + safeName + ' de ' + f.name + ': ' + err); }
      }
    } else {
      ui.appendLog('Nenhum anexo.');
    }
    // generate PDF (Outlook style) and add to folder
    ui.setSub('Gerando PDF (estilo Outlook)...');
    try{
      const pdfBlob = await renderEmailToPdf(parsed, 900); // width px
      folder.file('email_outlook_style.pdf', pdfBlob);
      ui.appendLog('PDF gerado e adicionado.');
    }catch(err){
      ui.appendLog('Erro gerar PDF: ' + err);
      log('Erro ao gerar PDF para ' + f.name + ': ' + err);
    }
    // also include original .eml
    folder.file('email_original.eml', text);
    ui.setStatus('Concluído'); ui.setSub(savedAttachments ? (savedAttachments + ' anexo(s)') : 'Sem anexos');
    const percent = Math.round(((i+1)/total)*100); globalBar.style.width = percent + '%'; globalPercent.textContent = percent + '%';
    await sleep(60);
  }
  // finalize ZIP
  log('Gerando ZIP final...');
  zip.generateAsync({type:'blob'}, metadata => { const p = Math.round(metadata.percent); globalBar.style.width = p + '%'; globalPercent.textContent = p + '%'; })
    .then(blob => {
      const url = URL.createObjectURL(blob);
      downloadAllBtn.style.display = 'inline-flex';
      downloadAllBtn.href = url; downloadAllBtn.download = 'emails_organizados.zip';
      downloadAllBtn.onclick = ()=> setTimeout(()=> URL.revokeObjectURL(url), 20000);
      log('ZIP pronto. Clique em "Baixar tudo (ZIP)".');
    }).catch(err => log('Erro gerar ZIP: ' + err));
}

/* UI helpers */
function createFileRow(fileName){
  const row = document.createElement('div'); row.className='item';
  const left = document.createElement('div'); left.className='meta';
  const badge = document.createElement('div'); badge.className='badge'; badge.textContent='EML';
  const textWrap = document.createElement('div'); const title = document.createElement('div'); title.textContent = fileName;
  const sub = document.createElement('div'); sub.className='small'; sub.textContent='Aguardando...';
  textWrap.appendChild(title); textWrap.appendChild(sub);
  left.appendChild(badge); left.appendChild(textWrap);
  const right = document.createElement('div'); right.className='right';
  const status = document.createElement('div'); status.className='small'; status.textContent='Na fila'; right.appendChild(status);
  row.appendChild(left); row.appendChild(right);
  return {
    row,
    setStatus(msg){ status.textContent = msg; },
    setSub(msg){ sub.textContent = msg; },
    appendLog(t){ log('['+fileName+'] ' + t); }
  };
}

</script>
</body>
</html>
