<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Organizador de E-mails (.eml) — Offline</title>

<!-- Estilo Microsoft-like, tons azul -->
<style>
  :root{
    --bg:#07142a;
    --card: rgba(255,255,255,0.04);
    --accent:#2b89ff;
    --accent-2:#5fb0ff;
    --muted: rgba(255,255,255,0.75);
    --glass: rgba(255,255,255,0.03);
    --success:#5ee39b;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: "Segoe UI", Roboto, Arial, sans-serif;
    background: linear-gradient(180deg,var(--bg) 0%, #0b2340 100%);
    color:#eaf4ff; -webkit-font-smoothing:antialiased;
  }
  .wrap{
    max-width:980px; margin:28px auto; padding:22px;
  }
  header{
    display:flex; align-items:center; gap:18px;
  }
  .logo {
    width:56px; height:56px; border-radius:12px;
    background: linear-gradient(135deg,var(--accent),var(--accent-2));
    display:flex; align-items:center; justify-content:center;
    font-weight:700; font-size:20px; color:#052034;
    box-shadow: 0 6px 24px rgba(43,137,255,0.18);
  }
  h1{margin:0; font-size:20px}
  p.lead{margin:6px 0 0; color:var(--muted); font-size:13px}

  .card{margin-top:18px; background:var(--card); border-radius:14px; padding:18px; box-shadow:0 8px 30px rgba(2,6,23,0.35);}

  .controls{display:flex; gap:12px; align-items:center; flex-wrap:wrap}
  .drop{
    border:2px dashed rgba(127,189,255,0.16);
    background:var(--glass); border-radius:12px; padding:28px;
    display:flex; align-items:center; gap:20px; cursor:pointer;
    transition:all .18s ease; min-height:150px;
  }
  .drop.hover{ background: rgba(93,154,255,0.06); transform:translateY(-4px); box-shadow:0 12px 40px rgba(11,34,64,0.45); }
  .drop .info{flex:1}
  .drop h2{margin:0; color:var(--accent-2); font-size:18px}
  .drop p{margin:6px 0 0; color:var(--muted); font-size:13px}
  .btn{background:var(--accent); color:#052034; padding:10px 14px; border-radius:10px; font-weight:700; border:none; cursor:pointer}
  .btn.alt{background:transparent; color:var(--accent-2); border:1px solid rgba(95,176,255,0.12)}
  input[type=file]{display:none}

  .options{display:flex; gap:10px; margin-top:12px; flex-wrap:wrap}
  .chip{padding:8px 12px; background:rgba(255,255,255,0.02); border-radius:10px; font-size:13px; color:var(--muted)}
  .chip input{margin-right:8px}

  .progressWrap{margin-top:14px}
  .bar{width:100%; height:10px; background:rgba(255,255,255,0.05); border-radius:8px; overflow:hidden}
  .bar > span{display:block; height:100%; background:linear-gradient(90deg,var(--accent),var(--accent-2)); width:0%}

  .list{margin-top:14px; display:grid; gap:10px}
  .item{display:flex; justify-content:space-between; gap:12px; padding:10px; border-radius:10px; background: rgba(0,0,0,0.18); align-items:center}
  .meta{display:flex; gap:12px; align-items:center}
  .badge{background:rgba(255,255,255,0.04); padding:6px 8px; border-radius:8px; font-weight:600; color:var(--muted); font-size:13px}
  .small{font-size:13px; color:var(--muted)}
  .right{display:flex; gap:8px; align-items:center}

  footer{margin-top:18px; display:flex; justify-content:space-between; align-items:center; gap:12px}
  .downloadAll{background:linear-gradient(90deg,var(--accent),var(--accent-2)); color:#042034; padding:10px 14px; border-radius:10px; font-weight:800; border:none; cursor:pointer}

  pre.log{margin-top:12px; max-height:220px; overflow:auto; background:rgba(0,0,0,0.2); padding:10px; border-radius:8px; color:#dff3ff; font-size:13px}
  .muted{color:var(--muted)}
  @media(max-width:720px){ .wrap{padding:12px} .drop{flex-direction:column; text-align:center} footer{flex-direction:column; align-items:start} }
</style>

</head>
<body>
  <div class="wrap">
    <header>
      <div class="logo">EM</div>
      <div>
        <h1>Organizador de E-mails (.eml) — Offline</h1>
        <p class="lead">Arraste arquivos .eml para extrair anexos (PDF, imagens, docx, xlsx...) e gerar pastas/ZIPs organizados automaticamente.</p>
      </div>
    </header>

    <div class="card">
      <div id="drop" class="drop" tabindex="0">
        <div class="info">
          <h2>Arraste e solte arquivos .eml aqui</h2>
          <p class="muted">Ou clique para seleccionar. Podes soltar vários de uma vez — cada um vira uma pasta com nome por data+assunto.</p>
          <div style="margin-top:10px" class="options">
            <label class="chip"><input id="optAll" type="checkbox" checked />Extrair todos os tipos (pdf, imagens, docx...)</label>
            <label class="chip"><input id="optDate" type="checkbox" checked />Criar pasta com data</label>
            <label class="chip"><input id="optHtml" type="checkbox" checked />Incluir corpo HTML</label>
          </div>
        </div>
        <div>
          <button class="btn" id="btnBrowse">Selecionar arquivos</button>
          <input id="fileInput" type="file" accept=".eml" multiple />
        </div>
      </div>

      <div class="progressWrap">
        <div style="display:flex; justify-content:space-between; align-items:center">
          <div class="small">Progresso global</div>
          <div class="small" id="globalPercent">0%</div>
        </div>
        <div class="bar" aria-hidden><span id="globalBar"></span></div>
      </div>

      <div class="list" id="fileList"></div>

      <footer>
        <div class="muted">Resultado local — nenhum servidor. ZIP gerado no browser.</div>
        <div>
          <a id="downloadAll" class="downloadAll" style="display:none">Baixar tudo (ZIP)</a>
        </div>
      </footer>

      <pre id="log" class="log" aria-live="polite"></pre>
    </div>
  </div>

  <!-- JSZip CDN (pode guardar local se quiser usar offline total) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>

<script>
/*
  Offline .eml organizer - Versão corrigida e completa
  - parses multiple .eml
  - extracts headers, body (text/html and text/plain), attachments
  - builds a ZIP with folders named YYYYMMDD_Subject (sanitized)
  - shows per-file and global progress
*/

const drop = document.getElementById('drop');
const fileInput = document.getElementById('fileInput');
const btnBrowse = document.getElementById('btnBrowse');
const fileList = document.getElementById('fileList');
const logEl = document.getElementById('log');
const downloadAllBtn = document.getElementById('downloadAll');
const globalBar = document.getElementById('globalBar');
const globalPercent = document.getElementById('globalPercent');
const optAll = document.getElementById('optAll');
const optDate = document.getElementById('optDate');
const optHtml = document.getElementById('optHtml');

btnBrowse.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', (e)=> handleFiles(e.target.files));

// prevenção global para não abrir o .eml em nova aba ao soltar fora da área
['dragover','drop'].forEach(ev => {
  window.addEventListener(ev, e => {
    e.preventDefault();
  });
});

// drag & drop apenas na área destacada
['dragenter','dragover'].forEach(ev => {
  drop.addEventListener(ev, (e)=> {
    e.preventDefault();
    e.stopPropagation();
    if(e.dataTransfer){ e.dataTransfer.dropEffect = 'copy'; }
    drop.classList.add('hover');
  });
});
['dragleave','drop'].forEach(ev => {
  drop.addEventListener(ev, (e)=> {
    e.preventDefault();
    e.stopPropagation();
    drop.classList.remove('hover');
  });
});
drop.addEventListener('drop', (e)=> {
  e.preventDefault();
  e.stopPropagation();
  const files = e.dataTransfer.files;
  handleFiles(files);
});
drop.addEventListener('click', ()=> fileInput.click());

function log(msg){
  logEl.textContent += msg + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}

function sanitizeName(s){
  if(!s) return '';
  // replace whitespace, remove forbidden filesystem chars including slash, backslash
  return s.replace(/\s+/g,'_').replace(/[<>:"\/\\|?*]+/g,'').replace(/\.+$/,'').slice(0,120);
}

function parseHeaders(headerText){
  const headers = {};
  // unfold folded headers (lines starting with space/tab)
  headerText = headerText.replace(/\r?\n[ \t]+/g, ' ');
  headerText.split(/\r?\n/).forEach(line=>{
    const idx = line.indexOf(':');
    if(idx>0){
      const name = line.slice(0,idx).trim().toLowerCase();
      const val = line.slice(idx+1).trim();
      if(headers[name]) headers[name] += '\n' + val; else headers[name]=val;
    }
  });
  return headers;
}

// get boundary from content-type header
function getBoundary(contentType){
  if(!contentType) return null;
  const m = contentType.match(/boundary=(?:"([^"]+)"|([^;\s]+))/i);
  return m ? (m[1] || m[2]) : null;
}

// parse one .eml text into structured object
function parseEml(text){
  // Normalize line endings to \n
  text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  // split headers/body at first blank line
  const idx = text.indexOf('\n\n');
  const headerRaw = idx>=0 ? text.slice(0,idx) : '';
  const bodyRaw = idx>=0 ? text.slice(idx+2) : '';

  const headers = parseHeaders(headerRaw);

  // Basic simple subject/from/date
  const subject = headers['subject'] || '(sem assunto)';
  const from = headers['from'] || headers['sender'] || '';
  const date = headers['date'] || '';

  // Determine top-level content-type
  const topContentType = headers['content-type'] || '';
  const boundary = getBoundary(topContentType);

  const result = { subject, from, date, headers, bodyPlain: null, bodyHtml: null, attachments: [] };

  // If multipart
  if(boundary){
    const parts = splitByBoundary(bodyRaw, boundary);
    for(const part of parts){
      // split part headers/body
      const i = part.indexOf('\n\n');
      if(i<0) continue;
      const ph = part.slice(0,i);
      const pb = part.slice(i+2);
      const pheaders = parseHeaders(ph);

      const ctype = pheaders['content-type'] || '';
      const cdisp = pheaders['content-disposition'] || '';
      const cte = (pheaders['content-transfer-encoding'] || '').toLowerCase();

      // find filename if present
      let filename = null;
      const fnMatch = (cdisp && cdisp.match(/filename=(?:"([^"]+)"|([^;\s]+))/i)) || (ctype && ctype.match(/name=(?:"([^"]+)"|([^;\s]+))/i));
      if(fnMatch) filename = (fnMatch[1] || fnMatch[2]).trim();

      // If it's text/plain or text/html and no filename, treat as body
      if(/text\/plain/i.test(ctype) && !filename){
        result.bodyPlain = decodePartBody(pb, cte);
      } else if(/text\/html/i.test(ctype) && !filename){
        result.bodyHtml = decodePartBody(pb, cte);
      } else {
        // attachment or inline
        if(filename){
          const contentBase64 = extractBase64FromPart(pb, cte);
          result.attachments.push({
            name: filename,
            contentBase64,
            contentType: getMimeFromContentType(ctype) || 'application/octet-stream',
            headers: pheaders
          });
        } else {
          // sometimes file attachments appear as base64 without filename but with content-type name parameter
          const nameFromTypeMatch = ctype ? ctype.match(/name=(?:"([^"]+)"|([^;\s]+))/i) : null;
          const nameFromType = nameFromTypeMatch ? (nameFromTypeMatch[1] || nameFromTypeMatch[2]) : null;
          if(nameFromType){
            const contentBase64 = extractBase64FromPart(pb, cte);
            result.attachments.push({
              name: nameFromType.trim(),
              contentBase64,
              contentType: getMimeFromContentType(ctype) || 'application/octet-stream',
              headers: pheaders
            });
          } else {
            // fallback: try to detect base64 block and create a generic attachment name
            const possibleBase64 = pb.match(/[A-Za-z0-9+/=\s]{200,}/);
            if(possibleBase64){
              const contentBase64 = stripBase64Whitespace(possibleBase64[0]);
              result.attachments.push({
                name: 'anexo_desconhecido.bin',
                contentBase64,
                contentType: getMimeFromContentType(ctype) || 'application/octet-stream',
                headers: pheaders
              });
            }
          }
        }
      }
    }
  } else {
    // not multipart: bodyRaw is the whole body, assume text/plain or text/html guess
    if(/<\s*html/i.test(bodyRaw) || /<div|<p/i.test(bodyRaw)){
      result.bodyHtml = bodyRaw;
    } else {
      result.bodyPlain = bodyRaw;
    }
  }

  // fallback: if no bodyHtml but bodyPlain exists, create simple HTML version
  if(!result.bodyHtml && result.bodyPlain && optHtml.checked){
    result.bodyHtml = '<pre style="white-space:pre-wrap; font-family:inherit; color:#001f3f; background:#f2fbff; padding:12px; border-radius:8px;">' + escapeHtml(result.bodyPlain) + '</pre>';
  }

  return result;
}

function getMimeFromContentType(ctype){
  if(!ctype) return null;
  const m = ctype.match(/^([^;\s]+)/);
  return m ? m[1] : null;
}

// split by boundary string robustly
function splitByBoundary(body, boundary){
  // boundary may be quoted or not; delim is --boundary
  const delim = '--' + boundary;
  // ensure consistent newlines
  const cleaned = body.replace(/\r\n/g,'\n');
  const parts = cleaned.split(delim).map(s => s.trim()).filter(s => s && s !== '--');
  return parts.map(p => {
    if(p.endsWith('--')) return p.slice(0,-2).trim();
    return p;
  }).filter(p => p.length>0);
}

// decode body with cte (content-transfer-encoding)
function decodePartBody(partBody, cte){
  if(!cte) return partBody;
  if(cte.includes('base64')) {
    try {
      // base64 decode to string (may be binary though)
      const b64 = stripBase64Whitespace(partBody);
      // try to decode as UTF-8 text
      try {
        const bytes = base64ToUint8Array(b64);
        const decoder = new TextDecoder('utf-8', { fatal: false });
        return decoder.decode(bytes);
      } catch(e){
        // fallback to atob string
        return atob(b64);
      }
    } catch(e){ return partBody; }
  } else if(cte.includes('quoted-printable')){
    return decodeQuotedPrintable(partBody);
  } else {
    return partBody;
  }
}

function stripBase64Whitespace(s){ return s.replace(/\s+/g,''); }

function decodeQuotedPrintable(str){
  // basic quoted-printable decode
  let res = str.replace(/=\r\n/g, ''); // soft line breaks
  // Replace =HH hex codes
  res = res.replace(/=([0-9A-F]{2})/gi, (m, p1) => String.fromCharCode(parseInt(p1, 16)));
  // handle underscores used as spaces in some encodings (rare)
  return res;
}

function extractBase64FromPart(pb, cte){
  let candidate = pb.trim();
  if(cte && cte.includes('base64')){
    return stripBase64Whitespace(candidate);
  }
  // sometimes pb contains headers or boundary markers; try to find the longest base64-like block
  const m = candidate.match(/[A-Za-z0-9+/= \r\n]{200,}/);
  return m ? stripBase64Whitespace(m[0]) : '';
}

function escapeHtml(s){
  if(!s) return '';
  return s.replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
}

// convert base64 to Uint8Array
function base64ToUint8Array(base64){
  const binary = atob(base64);
  const len = binary.length;
  const arr = new Uint8Array(len);
  for(let i=0;i<len;i++){ arr[i]=binary.charCodeAt(i); }
  return arr;
}

async function handleFiles(fileListObj){
  const files = Array.from(fileListObj).filter(f=> f.name && f.name.toLowerCase().endsWith('.eml'));
  if(files.length===0){ alert('Selecione ficheiros .eml'); return; }
  // reset UI
  fileList.innerHTML = '';
  logEl.textContent = '';
  downloadAllBtn.style.display='none';
  globalBar.style.width='0%'; globalPercent.textContent='0%';

  const zip = new JSZip();
  const total = files.length;

  // preparar linhas da lista
  const uiItems = files.map(f => createFileRow(f.name));
  uiItems.forEach(it => fileList.appendChild(it.row));

  for(let i=0;i<files.length;i++){
    const f = files[i];
    const ui = uiItems[i];
    ui.setStatus('Lendo ficheiro...');

    let text;
    try{
      text = await f.text();
    }catch(err){
      ui.setStatus('Erro ao ler ficheiro');
      log('Erro a ler ' + f.name + ': ' + err);
      continue;
    }

    ui.setSub('Parseando EML...');
    await sleep(60);

    let parsed;
    try {
      parsed = parseEml(text);
    } catch(err){
      ui.setStatus('Erro ao parsear');
      ui.setSub('Verifique se o .eml não está corrompido');
      log('Erro parse EML ' + f.name + ': ' + err);
      continue;
    }

    ui.setStatus('Extraindo partes...');
    // create folder name: DATE_SUBJECT or SUBJECT
    const dt = new Date(parsed.date || Date.now());
    const dateStr = optDate.checked ? dt.toISOString().slice(0,10).replace(/-/g,'') + '_' : '';
    const subjClean = sanitizeName(parsed.subject || 'sem_assunto');
    const folderName = dateStr + subjClean;
    const folder = zip.folder(folderName);

    // add metadata file
    const meta = `Remetente: ${parsed.from || ''}\nAssunto: ${parsed.subject || ''}\nData: ${parsed.date || ''}\n`;
    folder.file('info.txt', meta);

    // include body files
    if(parsed.bodyPlain){
      folder.file('corpo.txt', parsed.bodyPlain);
    }
    if(parsed.bodyHtml && optHtml.checked){
      // ensure it's valid html: wrap minimal html
      const htmlDoc = `<!doctype html><meta charset="utf-8"><title>${escapeHtml(parsed.subject||'email')}</title><body>${parsed.bodyHtml}</body>`;
      folder.file('corpo.html', htmlDoc);
    }

    ui.setSub('Salvando anexos...');
    let savedAttachments = 0;
    if(parsed.attachments && parsed.attachments.length){
      const attFolder = folder.folder('anexos');
      for(let aidx=0;aidx<parsed.attachments.length;aidx++){
        const att = parsed.attachments[aidx];
        if(!att || !att.contentBase64) continue;

        const rawName = att.name || ('anexo_' + (aidx+1));
        const safeName = sanitizeName(rawName);

        // se a opção "todos os tipos" não estiver marcada, filtra principais extensões
        if(!optAll.checked){
          const mime = (att.contentType || '').toLowerCase();
          const allowed = ['pdf','jpeg','jpg','png','gif','doc','docx','xls','xlsx','csv','txt','ppt','pptx'];
          const hasAllowedExt = allowed.some(ext => safeName.toLowerCase().endsWith('.' + ext));
          const isPdfOrImage = /pdf|image\//.test(mime);
          if(!hasAllowedExt && !isPdfOrImage) {
            ui.appendLog('Ignorado (não permitido): ' + safeName);
            continue;
          }
        }

        try{
          const arr = base64ToUint8Array(att.contentBase64);
          attFolder.file(safeName, arr);
          savedAttachments++;
          ui.appendLog(`Anexo salvo: ${safeName}`);
        }catch(err){
          log('Erro ao salvar anexo ' + safeName + ' do ficheiro ' + f.name + ': ' + err);
        }
      }
    }

    ui.setStatus('Concluído');
    ui.setSub(savedAttachments ? (savedAttachments + ' anexo(s) guardado(s)') : 'Sem anexos encontrados');

    const percent = Math.round(((i+1)/total)*100);
    globalBar.style.width = percent + '%';
    globalPercent.textContent = percent + '%';
    await sleep(50);
  }

  if(total>0){
    uiReadyForDownload(zip);
  }
}

function uiReadyForDownload(zip){
  log('Gerando ZIP...');
  // show progressive callback while generating
  zip.generateAsync({type:'blob'}, metadata => {
    const percent = Math.round(metadata.percent);
    globalBar.style.width = percent + '%';
    globalPercent.textContent = percent + '%';
  }).then(blob => {
    const url = URL.createObjectURL(blob);
    downloadAllBtn.style.display = 'inline-flex';
    downloadAllBtn.href = url;
    downloadAllBtn.download = 'emails_eml_extracao.zip';
    downloadAllBtn.onclick = ()=> setTimeout(()=>{ URL.revokeObjectURL(url); }, 20000);
    log('ZIP pronto para download.');
  }).catch(err => {
    log('Erro ao gerar ZIP: ' + err);
  });
}

function createFileRow(fileName){
  const row = document.createElement('div');
  row.className = 'item';

  const left = document.createElement('div');
  left.className = 'meta';

  const badge = document.createElement('div');
  badge.className = 'badge';
  badge.textContent = 'EML';

  const textWrap = document.createElement('div');
  const title = document.createElement('div');
  title.textContent = fileName;

  const sub = document.createElement('div');
  sub.className = 'small';
  sub.textContent = 'Aguardando...';

  textWrap.appendChild(title);
  textWrap.appendChild(sub);

  left.appendChild(badge);
  left.appendChild(textWrap);

  const right = document.createElement('div');
  right.className = 'right';
  const status = document.createElement('div');
  status.className = 'small';
  status.textContent = 'Na fila';
  right.appendChild(status);

  row.appendChild(left);
  row.appendChild(right);

  return {
    row,
    setStatus(msg){ status.textContent = msg; },
    setSub(msg){ sub.textContent = msg; },
    appendLog(t){ log('['+fileName+'] ' + t) }
  };
}

function sleep(ms){
  return new Promise(res => setTimeout(res, ms));
}
</script>

</body>
</html>
